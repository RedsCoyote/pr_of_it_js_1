/* Напишите функцию, которая вычисляет факториал натурального числа (освежите в памяти, что такое "факториал",
 к примеру, в Википедии). В первом варианте этой функции пользоваться рекурсией запрещено - функция не должна
 вызывать сама себя! */

function factorial(n) {
  let result = 1;

  if (n % 1 !== 0 || n < 0) {
    return false;
  }

  for (let i = 1; i <= n; i++) {
    result *= i;
  }

  return result;
}

console.log(factorial(4));  // => 24 == 4!
console.log(factorial(-4));  // => false: нельзя считать факториал отрицательного числа
console.log(factorial(4.2));  // => false: нельзя считать факториал нецелого числа

/* А теперь попробуйте на основе того простого факта, что n! = n * (n-1)! упростить код, сделав функцию рекурсивной
 (то есть такой, которая когда нужно вызывает сама себя) */
// Спорный вопрос, что код стал проще, имхо факториал и без рекурсии прекрасно всегда считался
function factorialRecursive(n) {
  if (n % 1 !== 0 || n < 0) {
    return false;
  }

  if (n === 1) {
    return 1;
  }

  return n * factorialRecursive(n - 1);
}

console.log(factorialRecursive(4));  // => 24 == 4!
console.log(factorialRecursive(-4));  // => false: нельзя считать факториал отрицательного числа
console.log(factorialRecursive(4.2));  // => false: нельзя считать факториал нецелого числа

/* Попробуйте замерить производительность (скорость работы) этих двух вариантов функции. */
// собственно задача сводится к нахождению способа засечь время до и после выполнения функции
// performance.now() - работает в браузере, т.к. пробовал в ноде, пришлось искать дальше
let timeNotRec = 0, timeRec = 0, repeats = 1000;

for (let i = 0, time = 0; i < repeats; i++) {
  let time = process.hrtime();
  factorial(400);
  time = process.hrtime(time);
  timeNotRec += time[0] + time[1] / 1e9;
  time = process.hrtime();
  factorialRecursive(400);
  time = process.hrtime(time);
  timeRec += time[0] + time[1] / 1e9;
}

console.log('Время выполнения без рекурсии = ', timeNotRec / repeats + ' sec');  // => 0.000005596612000000002 sec
console.log('Время выполнения с рекурсией  = ', timeRec / repeats + ' sec');     // => 0.000013883723000000012 sec
// ожидаемо, время выполнения без рекурсии ниже, чем с рекурсией и чем от большего числа вычисляется факториал,
// тем заметнее

/* то значит запись второго аргумента.
Придумайте свой вариант полезной функции, использующей такую запись. */
// т.к. такая запись встречается во многих языках, то не догадаться было трудно - это значение параметра по-умолчанию
// если функция будет вызвана без второго параметра, то внутри ее тела он будет иметь значение заданное по-умолчанию
// вместо undefined
// используется как раз вместо написания примерно такого кода:
function setColor(text, color) {
	if (undefined === color) {
		color = 'black';
	}
	return text.color = color;
}
// это можно упростить до 
function setColor(text, color = 'black') {
	return text.color = color;
}
// пример конечно очень надуманный, но как назло ничего реально полезного во голову не лезло

/* может ли функция вернуть функцию? И если да, то как потом использовать функцию, которую вернула другая функция? */
// Да без проблем, а использовать: можно присвоить переменной, можно сразу выполнить:
function func() {
	return function () {
		return 40 + 2;
	}
}

let myFunc = func();
console.log(myFunc()); // => 42
console.log(func()()); // => 42

// Как уже говорили на вебинаре, на этом основаны замыкания в JS
let counter = (function () {
	let counter = 1;
	return function () {
		return counter++;
	}
})();

console.log(counter()); // => 1
console.log(counter()); // => 2
console.log(counter()); // => 3
// офигеть, я впервые написал такой счетчик не заглядывая ни в какие мануалы )))

